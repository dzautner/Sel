-----------------------------------------------------
-- Let there be light! 
-- https://en.wikipedia.org/wiki/Identity_function
-----------------------------------------------------
(let Identity        (λ x x))

-------------------
-- Boolean Logic --
-------------------
(let True            (λ t (λ f t)))
(let False           (λ t (λ f f)))
(let ∧               (λ p (λ q ((p q) p))))
(let ∨               (λ p (λ q ((p p) q))))
(let ¬               (λ c ((c False) True)))
(let If              (λ c (λ t (λ f ((c t) f)))))

-----------------------------------------------------
-- Real Numbers & Numerical Operations with Church Numerals
-- See: https://en.wikipedia.org/wiki/Church_encoding#Church_numerals
-----------------------------------------------------

(let 0               (λ f Identity))
(let Is-Zero         (λ n ((n (λ _ False)) True)))

(let Successor       (λ n (λ f (λ x (f ((n f) x))))))
(let Predecessor     (λ n (((Is-Zero n) 0) (λ f (λ x (((n (λ g (λ h (h (g f))))) (λ _ x)) (λ u u)))))))
(let +               (λ m (λ n ((n Successor) m))))
(let -               (λ m (λ n ((n Predecessor) m))))
(let *               (λ m (λ n (λ f (m (n f))))))
(let Power           (λ x (λ y (y x))))
(let Abs-Difference  (λ x (λ y ((+ ((- x) y)) ((- y) x)))))

(let <               (λ m (λ n (¬ ((≤ n) m)))))
(let ≤               (λ m (λ n (Is-Zero ((- m) n)))))
(let =               (λ m (λ n ((∧ ((≤ m) n)) ((≤ n) m)))))
(let ≠               (λ m (λ n ((∨ (¬ ((≤ m) n))) (¬ ((≤ n) m))))))
(let >               (λ m (λ n (¬ ((≤ m) n)))))
(let ≥               (λ m (λ n ((≤ n) m))))
(let ∅               (λ x True))
(let Is-Null         (λ l (λ h (True (λ d False)))))

(let 1               (Successor 0))
(let 2               (Successor 1))
(let 3               (Successor 2))
(let 4               (Successor 3))
(let 5               (Successor 4))
(let 6               (Successor 5))
(let 7               (Successor 6))
(let 8               (Successor 7))
(let 9               (Successor 8))
(let 10              (Successor 9))


----
-- The Y combinator, allowing recrusive definitions without "cheating" by using named functions.
--
--  λf· (λx· f (x x)) (λx· f (x x))
--
-- "Discovered" (or "Invented", depends on the reader) by Haskell B. Curry,
-- It truly one of the cuter Sudokus in Lambda Calculus.
--
-- Once we are able to use recursion, there is nothing really stopping us from structuring complex algorithms.
----
(let Y         (λ f ((λ x (f (λ y ((x x) y)))) (λ x (f (λ y ((x x) y)))))))


--- A pair is our first data-structure that can hold arbitary data.
--- The implementation is quite clear, it simply accepts two values to "pack"
--- and returns a function that could have a function applied that that would have those two values "unpacked" into.
(let Pair      (λ x (λ y (λ f ((f x) y)))))

-- Helpers for returning the Left/Right side of the pair
(let Left      (λ p (p True)))
(let Right     (λ p (p False)))

--- A Triple has a similar implementation to the Pair, but with 3 values instead.
(let Triple    (λ x (λ y (λ z (λ f (((f x) y) z))))))

------------------
-- Linked Lists --
------------------

--- The List implemenation is simply using the Triple defined before to hold 3 references:
--- A Value of the current Node
--- The rest of the List
--- A flag indicating is the list empty or not.
---
--- Note the later is not exactly nessecery as we could have used a Null terminator in the value field
--- and only use a pair for the implementation, but implementing using a Triple and a flag proved easier. 
(let List      (λ h (λ t (((Triple h) t) False))))
(let EmptyList (((Triple 0) 0) True))

--- The head of the list is simple the left most part of the Triple
(let Head      (λ l (l (λ h (λ t (λ n h))))))

--- The tail is the middle part of the Triple
(let Tail      (λ l (l (λ h (λ t (λ n t))))))

--- Is-Empty is the flag in the right most part of the Triple.
(let Is-Empty  (λ l (l (λ h (λ t (λ n n))))))


--- A show case of common algorithms using the Linked List implementation above and the Y combinator. 
(let Nth (Y (λ f (λ l (λ n
  ((((If (Is-Zero n))
   (λ _ (Head l)))
   (λ _ ((f (Tail l)) (Predecessor n))))
   ∅))))))

(let Fold (Y (λ f (λ l (λ m (λ a
  ((((If (Is-Empty l))
   (λ _ a))
   (λ _ (((f (Tail l)) m) ((m a) (Head l)))))
   ∅)))))))

(let MapRight (λ l (λ f (((Fold l) (λ nl (λ m ((List (f m)) nl)))) EmptyList))))
(let Reverse  (λ l ((MapRight l) Identity)))
(let Map      (λ l (λ f (Reverse ((MapRight l) f)))))
(let Length   (λ l (((Fold l) (λ len (λ _ (Successor len)))) 0)))

(let Filter (λ l (λ p
  (((Fold l) (λ acc (λ m
   ((((If (p m))
   (λ _ ((List m) acc)))
   (λ _ acc))
   ∅))))
  EmptyList))))


---------------------
-- Signed Integers --
---------------------

-- Integer signs:
(let Positive True)
(let Negative False)

-- An integer is just a pair of a sign an a real number
(let Integer ((λ sign (λ number ((Pair sign) number)))))


--- Helpers
(let Integer-To-Sign (λ int (Left Int)))
(let Integer-To-Real (λ int (Right int)))
(let Is-Positive (λ int (Left int)))
(let Is-Negative (λ int (¬ (Is-Positive int))))

(let IntegerSuccessor (λ n
            (((Is-Zero (Integer-To-Real n)) 
                ((Integer Positive) 1))
                (((Is-Positive n) ((Integer Positive) (Successor (Integer-To-Real n))))
                                    ((Integer Negative) (Predecessor (Integer-To-Real n)))))))

(let IntegerPredecessor (λ n
            (((Is-Zero (Integer-To-Real n)) 
                ((Integer Negative) 1))
                (((Is-Positive n) ((Integer Positive) (Predecessor (Integer-To-Real n))))
                                    ((Integer Negative) (Successor (Integer-To-Real n))))))))



--- Integer Operations
(let IntegerAddition      (λ m (λ n (((Integer-To-Real n)
                            (((Is-Positive n) 
                                IntegerSuccessor)
                                IntegerPredecessor))
                            m))))

(let IntegerSubstraction  (λ m (λ n (((Integer-To-Real n)
                            (((Is-Positive n) 
                                IntegerPredecessor)
                                IntegerSuccessor))
                            m))))


------
-- A small helper to decide the sign of a product of two Integers.
------

(let IntegerMultipicationSign (λ m (λ n
    ((((∧ (Is-Negative n)) (Is-Negative m))
        Positive)
     ((((∨ (Is-Negative n)) (Is-Negative m))
        Negative)
        Positive))
)))

--- Multiplying Integers is simply a pair of the product of signs and product of reals.
(let IntegerMultiplication (λ m (λ n
    ((Integer 
        ((IntegerMultipicationSign m) n))
    ((* (Integer-To-Real m)) (Integer-To-Real n)))
)))

